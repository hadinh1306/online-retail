---
title: "EDA"
author: "Ha Dinh"
date: '2018-08-02'
output: 
  html_document:
    keep_md: yes
---

```{r setup, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(lubridate)
library(stringr)
```

Load data.

```{r}
df <- read_csv("../data/raw/online_retail.csv")
head(df)
```

# Data Structure and Validation

Look at the structure of data to see if we need to transform any variables for later analysis, or if we have missing values and any outliers.

```{r}
str(df)
summary(df)
```

From data summary, 

1. I confirm that `UnitPrice` is larger than 0. `Quantity` has negative numbers which indicate returns.

2. I'm curious how many countries are there in the data, and how many transactions each country had.

There are 38 countries present in this dataset, but 92% of observations belong to United Kingdom. Customer segmentation in different countries can be different. Thus, for this project, I'll focus on United Kingdom only. 

```{r}
df %>% 
  group_by(Country) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n))
```

Let's filter data to get only observations from United Kingdom.

```{r}
ukdf <- df %>% 
  filter(Country == "United Kingdom")
```

3. There are 66659 missing values in `CustomerID`. Since the purpose of this project is to segment customers using RFM methods, we need `CustomerID` to identify each customer. We can't identify through `InvoiceNo` since each customer can purchase more than 1 time. Thus, I'll remove all of these missing values. 

```{r}
summary(ukdf)
```

```{r}
nonadf <- ukdf %>% 
  filter(!is.na(CustomerID))
```

2. Transform `InvoiceDate` from character to date form, removing hour and minute information. Note that transactions were recorded from December 1st, 2010.

```{r}
nonadf$InvoiceDate <- as_date(mdy_hm(nonadf$InvoiceDate))
```

3. There are outliers in `Quantity` and `UnitPrice`. Check distribution.

Ploting ECDF graphs for both `Quantity` and `UnitPrice`, I see that there are less than 5 outliers for each variable.

```{r}
plot(ecdf(nonadf$Quantity))
plot(ecdf(nonadf$UnitPrice))
```

I'm curious which customer(s) related to the 2 outliers in `Quantity`. It turns out that they belong to a single customer. He/she purchased a lot and returned them all.  

```{r}
nonadf %>% 
  filter(Quantity > 50000 | Quantity < -50000)
```

Let's check out `UnitPrice` outliers. Although from the ECDF plot, it appears that there are only 3 outliers, base on this table below, there are actually 4. 

3 of them belong to customer `16029`. He/she bought a `POSTAGE` worths 8142.75 and returned it, and also return a `Manual` worths 6930 on the same day. 

```{r}
nonadf %>% 
  filter(UnitPrice > 5000)
```

For now, I decide to keep all outliers since there is no clear insights about them, and there are less than 5 of them. 

# Data Preparation

The project focuses on customer segmentation using RFM, which stands for: 

- RECENCY (R): Days since last purchase
- FREQUENCY (F): Total number of purchases
- MONETARY VALUE (M): Total money this customer spent

I came across this [resource](https://towardsdatascience.com/find-your-best-customers-with-customer-segmentation-in-python-61d602f9eee6) and find it helpful to refer to for RFM model. My goal is to assign score for RMF and then segment for each customer base on his/her score. To do this, I need to calculate recency, frequency, and monetary value. 

Before I go into calculation and scoring, I want to understand each customer segment I assign to customers. 

| Segment | Description | 
|---------|-------------|
| Best Customers | Bought most recently and most often, and spend the most | 
| Loyal Customers | Buy most frequently | 
| Big Spenders | Spend the most | 
| Almost Lost | Haven't purchased for some time, but purchased frequently and spend the most | 
| Lost Customers | Haven't purchased for longer time than `Almost Lost` ones, but purchased frequently and spend the most | 
| Lost Cheap Customers | Last purchased long ago, purchased few, and spent little | 

## Recency

To calculate days since last purchase, I need to know what is the last day recorded in this data. The result is June 26th 2011. I will take June 27th 2011 as the present time to calculate recency. 

```{r}
max(nonadf$InvoiceDate)
```

```{r}
present = as_date("2011-06-27")
```

Now I calculate the recency table including `CustomerID` and `recency` - days since last purchase. Note that for this calculation, there is an assumption: There are many reasons that can lead to a return and there is no record of these reasons in the dataset. Thus, as long as customers make a purchase, we count their good intention toward our business and account this into recency, no matter if they return or not.

Note that there are 2689 customers in this dataset, so we should see at max 2689 observations for our recency, frequency and monetary value tables. 

```{r}
n_distinct(nonadf$CustomerID)
```

Below, we only have 2652 observations for recency table. This is because I filter to only have `Quantity` > 0 before calculate recency, avoiding counting return days. There are 37 customers who only returned in this dataset. Since they must have purchased before but that data is not in this dataset, I will filter out these 37 customers in my analysis. 

```{r}
(recency_df <- nonadf %>% 
  filter(Quantity > 0) %>% 
  group_by(CustomerID) %>% 
  summarise(recency = as.integer(present - max(InvoiceDate))))
```

## Frequency

To calculate the total number of purchases, I need to consider number of returns as well. 

`Total number of purchases = number of purchases - number of returns`

From my quick inspection for `UnitPrice` outliers above, I see that only returns have `InvoiceNo` starting with `C`. I confirm here that only `InvoiceNo`s starting with `C` are returns, while `InvoiceNo`s starting with numbers are purchases.

```{r}
# check if there are any InvoiceNo starting with C have positive quantity 
sum(nonadf[str_detect(nonadf$InvoiceNo, "^C"), ]$Quantity > 0)

# check if there are any InvoiceNo starting with numbers have negative quantity 
sum(nonadf[str_detect(nonadf$InvoiceNo, "^[:digit:]"), ]$Quantity < 0)
```

Now I calculate the number of purchases for each `CustomerID`.

```{r}
(frequency_df <- nonadf %>% 
  # create new column to detect return; 
  # if return then 0, else (if purchase) then 1
  mutate(return = ifelse(str_detect(nonadf$InvoiceNo, "^C"), 0, 1)) %>% 
  # calculate number of purchases for each customer
  group_by(CustomerID) %>% 
  summarise(frequency = sum(return)))
```

## Monetary value

To calculate the total money each customer spend, I take the sum of his/her revenue and loss. 

`Revenue/Loss = Quantity * Unit price`

```{r}
(money_df <- nonadf %>% 
  group_by(CustomerID) %>% 
  summarise(monetary_value = sum(Quantity*UnitPrice)))
```

## RFM table 

Now I combine results from recency, frequency, and monetary value tables to a single RFM dataframe. 

```{r}
rfm_df <- inner_join(recency_df, frequency_df) %>% 
  inner_join(money_df)

# View first 5 observations of RFM table
head(rfm_df, 5)
```

Customer `12346` made only 1 purchase 160 days ago, and returned his/her purchase. This customer is certainly not our best one. Let's see what he/she purchased and returned. 

It was a medium ceramic top storage jar of 1.04 per unit. This seems like a cheap price. The customer purchased 74215 units but returned them all.

```{r}
nonadf %>% 
  filter(CustomerID == 12346)
```

Like I mentioned in the beginning of Data Preparation session, I want to assign score for recency, frequency, and monetary value. These scores will help me to assign segment for each customer. I will assign 4 scores (1, 2, 3, 4) with 1 representing the best, and 4 representing the worst.

For recency, the best scenario is for the lowest recency, meaning a customer purchased something very recent.  

For both frequency and monetary value, the best scenario is for the highest frequency and value, meaning a customer purchased many time and spent a lot of money. 

One of the easiest way to assign score is based on quantiles. Here, I'll use 25%, 50%, and 75% quantiles. 

```{r}
rq <- quantile(rfm_df$recency, c(0.25, 0.5, 0.75))
fq <- quantile(rfm_df$frequency, c(0.25, 0.5, 0.75))
mq <- quantile(rfm_df$monetary_value, c(0.25, 0.5, 0.75))

rfm_df <- rfm_df %>% 
  mutate(R = ifelse(recency <= rq[[1]], 1,
                                  ifelse(recency <= rq[[2]], 2,
                                         ifelse(recency <= rq[[3]], 3, 4)))) %>% 
  mutate('F' = ifelse(frequency <= fq[[1]], 4, 
                      ifelse(frequency <= fq[[2]], 3, 
                             ifelse(frequency <= fq[[3]], 2, 1)))) %>% 
  mutate(M = ifelse(monetary_value <= mq[[1]], 4, 
                      ifelse(monetary_value <= mq[[2]], 3, 
                             ifelse(monetary_value <= mq[[3]], 2, 1))))
```

Now that we have scores for recency, frequency, and monetary value, let's find scores for each segment. 

| Segment | Description | RFM score | 
|---------|-------------|-----------|
| Best Customers | Bought most recently and most often, and spend the most | 1, 1, 1 | 
| Loyal Customers | Buy most frequently | ?, 1, ? | 
| Big Spenders | Spend the most | ?, ?, 1 | 
| Almost Lost | Haven't purchased for some time, but purchased frequently and spend the most | 3, 1, 1 | 
| Lost Customers | Haven't purchased for longer time than `Almost Lost` ones, but purchased frequently and spend the most | 4, 1, 1 | 
| Lost Cheap Customers | Last purchased long ago, purchased few, and spent little | 4, 4, 4 | 

For Loyal Customers and Big Spenders, `?` can either be 1 to 4, as long as RFM combination is not similar to other segments. 

Let's asign segment for each customer. Customers who are not in my list of segments are assigned to `Others` group for now. 

```{r}
rfm_df <- rfm_df %>%
  mutate(segment = ifelse(R == 1 & F == 1 & M == 1, "Best Customer", 
                          ifelse(R == 3 & F == 1 & M == 1, "Almost Lost",
                                 ifelse(R == 4 & F == 1 & M == 1, "Lost Customers",
                                        ifelse(R == 4 & F == 4 & M == 4, "Lost Cheap Customers", 
                                               ifelse(M == 1, "Big Spenders", 
                                                      ifelse(F == 1, "Loyal Customers", "Others")))))))
```

I want to join customer segment with the full dataset for visualization purpose later. 

```{r}
output_df <- rfm_df %>% 
  inner_join(nonadf)
```

I will export this file to csv file and visualize data using Tableau, with an inspiration from this [link](https://www.blastam.com/rfm-analysis-sample-dashboard). 

```{r}
write_csv(output_df, "../data/clean/segmented_data.csv")
```




